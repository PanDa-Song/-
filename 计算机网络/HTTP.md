## HTTP

## HTTP协议概述
- Hyper Text Transmission Protocol，超文本传输协议
- 客户端与服务端传输的内容称为报文
客户端-->服务端         请求报文
服务端-->客户端         响应报文
- HTTP协议即规定了一种规则，用于规定两种报文格式

### 请求报文格式

1. 例子：
```
Host: www.youtube.com
User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:73.0) Gecko/20100101 Firefox/73.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2
Accept-Encoding: gzip, deflate, br
Connection: keep-alive
Cookie: VISITOR_INFO1_LIVE=aGRTIWwhyq8; GPS=1; YSC=1-k7OMjUmBE
Upgrade-Insecure-Requests: 1
Cache-Control: max-age=0
TE: Trailers
```
2. 报文结构

- 请求首行：
    - 请求方法(Method) 
    - 资源路径(path) 
    - 协议版本(schema)
- 请求的头部信息（键值对）
    - Host：请求的是哪个服务器
    - User-agent：用户代理，显示用户客户端的详细信息
    - Accept：接收文件类型
- 空行
- 请求体
3. GET方法没有请求空行和请求体。POST方法有空行和请求体
另外，GET方法将请求数据放于首行，有长度限制(255)，而POST请求的请求数据位于请求体，适合提交大量内容


### 响应报文格式

1. 例子：
```
HTTP/2 200 OK
strict-transport-security: max-age=31536000
x-content-type-options: nosniff
content-encoding: br
expires: Tue, 27 Apr 1971 19:44:06 GMT
cache-control: no-cache
x-frame-options: SAMEORIGIN
content-type: text/html; charset=utf-8
date: Wed, 08 Apr 2020 01:41:40 GMT
server: YouTube Frontend Proxy
x-xss-protection: 0
alt-svc: quic=":443"; ma=2592000; v="46,43",h3-Q050=":443"; ma=2592000,h3-Q049=":443"; ma=2592000,h3-Q048=":443"; ma=2592000,h3-Q046=":443"; ma=2592000,h3-Q043=":443"; ma=2592000,h3-T050=":443"; ma=2592000
X-Firefox-Spdy: h2
```
2. 报文结构
- 响应首行
    - 协议版本 
    - 响应状态码 
    - 响应提示信息
- 响应头信息
    - server：服务器
    - content-type：服务器传回数据的内容类型
- 空行
- 响应体(服务器传递给客户端的响应数据，如html页面等)

3. 响应状态码

- 各数字开头的含义
    - 2：表示成功
    - 3：表示需要重新请求另一个资源
    - 4：表示资源未找到（请求地址出错）
    - 5：服务器内部错误（代码出错）
- 常见状态码
    - 200：请求成功，浏览器显示响应体内容
    - 301：（永久移动) 请求的网页已永久移动到新位置。 服务器返回此响应(对 GET 或 HEAD 请求的响应)时，会自动将请求者转到新位置。
    - 302：（临时移动）服务器要求浏览器重新再发一个请求，服务器会发送一个响应头location，指向了新请求的URL地址
    - 401：（未授权）需要身份验证
    - 403：服务器拒绝请求
    - 404：请求的资源未找到，说明客户端请求了不存在的资源
    - 500：请求资源找到了，但服务器内部出现了错误








## 发展史

### HTTP/0.9
- 早期协议，纯文本格式，且设置为了**只读**，也就是说只有GET方法从服务器获得HTML文件，响应后则关闭。

- 响应中只包含了文档本身。响应内容无响应头，无错误码，无状态码。

- 请求过程：
    - 应用层的HTTP建立在传输层的TCP之上并运用TCP可靠性等特性，先三次握手建立连接
    - 客户端请求建立连接(此时只有GET)
    - 服务端响应请求，数据以 ASCII 字符流返回给客戶端
    - 传输完成，断开连接。

### HTTP/1.0

- 增加POST方法（加参数），Head方法
- 加入协议版本号，同时添加文件处理类型，改进过去仅有的文件传输
- 加入HTTP Header，使处理请求更加灵活
- 增加响应状态码，标记出错原因

### HTTP/1.1

- 继续增加了PUT等方法
- 允许持久连接。由于文件越来越大，如果每次上传下载都需要建立连接断开连接，开销太大，于是出现持久连接，就是一次TCP连接可以具有多个HTTP请求。
- 支持 管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。
- 强制要求HOST头

### HTTP/2.0

- 1.1缺点
    - TCP自带慢启动
    - 多条TCP连接带宽竞争
    - 头部阻塞
- 2.0改进
    - 二进制分帧：头信息和数据体都是二进制，并且统称为帧（frame）：**头信息帧和数据帧**。
    - 多路复用/连接共享：**一个连接中并发多个请求或回应，而不用按照顺序一一对应**
    - 头部压缩
    - 请求优先级：数据流

### HTTP/3.0

由谷歌发起，命名为QUIC。**基于UDP**

- TCP限制
    - TCP可能间歇性的挂起（由于滑动窗口）
    - TCP不支持流级复用
    - TCP连接握手会有冗余的消息交换序列
- QUIC改进
    - 流复用和流控
    - 灵活的拥塞控制
    - 增强的丢失恢复机制和转发纠错功能
    - 更快的握手

## HTTPS

HTTP = HTTP + TLS/SSL

### 对比

- HTTP漏洞：
    - **窃听风险**，比如通信链路上可以获取通信内容
    - **篡改风险**，比如强制入垃圾广告，视觉污染
    - **冒充风险**，比如冒充淘宝网站
- HTTPS改进：
    - **信息加密**：交互信息无法被窃取
    - **校验机制**：无法篡改通信内容，篡改了就不能正常显示
    - **身份证书**：证明淘宝是真的淘宝网

### HTTPS原理

- **混合加密**保证机密性

    对称加密 + 不对称加密：在通信建立前采用非对称加密的方式交换「会话秘钥」，后续就不再使用非对称加密。在通信过程中全部使用对称加密的「会话秘钥」的方式加密明文数据。

- **摘要算法**实现完整性

    客户端在发送明文之前会通过摘要算法算出明文的「指纹」，发送的时候把「指纹 + 明文」一同加密成密文后，发送给服务器，服务器解密后，用相同的摘要算法算出发送过来的明文，通过比较客户端携带的「指纹」和当前算出的「指纹」做比较，若「指纹」相同，说明数据是完整的。

- **数字证书**保证正确性

    借助第三方权威机构 `CA` （数字证书认证机构），将**服务器公钥放在数字证书**（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。

### 连接过程

#### 基本流程

- 客户端向服务器索要并验证服务器的公钥。
- 双方协商生产「会话秘钥」。
- 双方采用「会话秘钥」进行加密通信

#### 握手过程

1. ClientHello

    客户端向服务器发起加密通信请求。

    向服务器发送以下信息：

    - 客户端支持的SSL/TLS版本
    - 客户端生产的随机数（Client Random），用于之后生成「会话秘钥」
    - 客户端支持的密码套件列表，如RSA加密算法

2. ServerHello

    服务器收到向客户端发出响应。

    向客户端回应以下信息：

    - 确认 SSL/ TLS 协议版本，如果浏览器不支持，则关闭加密通信。
    - 服务器生产的随机数（Server Random），后面用于生产「会话秘钥」
    - 确认的密码套件列表，如 RSA 加密算法
    - 服务器的数字证书

3. 客户端回应

    客户端收到服务端回应后，通过浏览器或操作系统的CA公钥，确认数字证书的真实性。

    若证书没问题，客户端从数字证书中取出服务器的公钥，用它加密报文。

    向服务器发送以下信息：

    - 一个随机数（pre-master key）。该随机数会被服务器公钥加密
    - 加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信
    - 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验

    **此时，双方各有这三个随机数，通过双方协商的加密算法，各自生成本次通信的「会话秘钥」**

4. 服务器的最后回应

    生成「会话秘钥」后，向客户端发送最后的信息：

    - 加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信
    - 服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验