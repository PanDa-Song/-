# 事务



## 概念

事务就是「一组原子性的SQL查询」，或者说一个独立的工作单元。如果数据库引擎能够成功地对数据库应用该组查询的全部语句，那么就执行该组查询。如果其中有任何一条语句因为崩溃或其他原因无法执行，那么所有的语句都不会执行。也就是说，事务内的语句，要么全部执行成功，要么全部执行失败。



## 基本语法

```mysql
BEGIN 或 START TRANSACTION 显式地开启一个事务；
COMMIT / COMMIT WORK二者是等价的。提交事务，并使已对数据库进行的所有修改成为永久性的；
ROLLBACK / ROLLBACK WORK。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改；
SAVEPOINT identifier 在事务中创建一个保存点，一个事务中可以有多个 SAVEPOINT；
RELEASE SAVEPOINT identifier 删除一个事务的保存点；
ROLLBACK TO identifier 把事务回滚到标记点；
SET TRANSACTION 用来设置事务的隔离级别。InnoDB 存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ 和 SERIALIZABLE
```



## ACID特性

- A (Atomicity, 原子性) 

    一个事务必须被视为一个不可分割的最小工作单元。各部分操作不可分（原子的）；要么都执行，要么都不执行。

- C (Consistency, 一致性) 

    当事务完成时，数据必须处于一致状态

- I (Isolation, 隔离性) 

    对数据进行修改的所有并发事务是彼此隔离的，也即对其他事物是不可见的，这表明事务必须是独立的，他不应以任何方式依赖于或影响其他事务

- D (Durability, 永久性) 

    事务完成后，他对数据库的修改被永久保持到数据库中，事务日志能够保持事务的永久性



## 读取面临问题

### 脏读

事务A已修改数据但还未提交，此时事务B来读取数据，若不加控制，事务B读取到A修改过的数据，之后A又提交它修改的数据，则B读到的是脏数据。即事务可以读取未提交的数据

### 不可重复读

同一事务内部，在读取某数据后的某个时间，再次读取以前读过的数据，读到的结果发生了变更或者被删除了

### 幻读

事务A在查询某个范围内的记录，事务B又在该范围内插入了新的满足条件的记录，当A再次查询时，会产生新的满足条件的记录

### 不可重复读 VS. 幻读

- 不可重复读的重点是修改：在同一事务中，同样的条件，第一次读的数据和第二次读的「数据不一样」。（因为中间有其他事务提交了修改）
- 幻读的重点在于新增或者删除：在同一事务中，同样的条件，第一次和第二次读出来的「记录数不一样」。（因为中间有其他事务提交了插入/删除）



## 隔离级别

四种隔离级别，每一种级别都规定了一个事务中所做的修改，哪些在事务内和事务间是可见的，哪些是不可见的。低级别的隔离级一般支持更高的并发处理，并拥有更低的系统开销。

- **READ UNCOMMITED（未提交读）**

    所有事务都可以看到其他事务未提交的修改。会导致很多问题，如脏读，所以很少用于实际应用

- **READ COMMITED（提交读）** 

    一个事务开始时，只能看见已经提交事务所做的修改，也就是，一个事务从开始直到提交前，所做的任何修改对其他事务都是不可见的。是大多数数据库系统默认的隔离级别，但MySQL不是

- **REPEATABLE READ（可重复读）** 

    确保同一事务的多个实例在并发读取数据时会看到相同的数据行。是MySQL的默认隔离级别，InnoDB引擎通过多版本并发控制(MVCC, Multiversion Concurrency Control)来实现

- **SERIALIZABLE（可串行化）** 

    最高的隔离级别，完全串行化读，通过强制事务串行执行，在每一行数据上都加锁，可能导致大量的超时和锁争用的问题。



| 隔离级别        | 脏读 | 不可重复读 | 幻读 |
| --------------- | ---- | ---------- | ---- |
| Read Uncommited | √    | √          | √    |
| Read Commited   | ×    | √          | √    |
| Repeatable Read | ×    | ×          | √    |
| Serializable    | ×    | ×          | ×    |



## 自动提交

MySQL默认采用自动提交（Autocommit）模式，即如果没有显示开始一个事务，则每个查询都被当做一个事务执行提交操作。

对于MyISAM这些非事务型表，修改AUTOCOMMIT不会有任何影响，对这类表来说没有COMMIT和ROLLBACK的概念，或者说是一直启用AUTOCOMMIT



## Reference

- https://mp.weixin.qq.com/s?__biz=MzIwMjM4NDE1Nw==&mid=2247483807&idx=1&sn=760d3b36c3742b0413b7f6f095506fd5&chksm=96de37eda1a9befb371bf03653df7528921262c95ab1483b4ecb86a25a8315a9598c723adaa5&scene=21#wechat_redirect