# 线程生命周期
## 五种线程状态
### 新建（NEW）

当程序使用 new 关键字创建了一个线程以后，该线程处于新建状态。

此时仅有 JVM 为期分配内存，并初始化其成员变量的值



### 就绪（Runnable）

当线程对象调用 start 方法后，该线程处于就绪状态。

JVM 为其创建方法调用栈和程序计数器，等待调度运行



### 运行（RUNNING）

处于就绪状态的线程获得了 CPU 使用权，开始执行 run 方法的线程执行体，则处于运行状态



### 阻塞（BLOCKED）

线程因为某些原因放弃 CPU 使用权，即让出 CPU 时间片，暂时停止运行。知道线程进入就绪状态，才有机会再次获得时间片转到运行状态。

阻塞有以下三种情况：

- 等待阻塞 (wait -> 等待队列)

  运行的线程执行 wait 方法，JVM 回吧该线程放入等待队列 (waiting queue)

- 同步阻塞 (lock -> 锁池)

  运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则 JVM 会把该线程放入锁池 (lock pool)

- 其他阻塞 (sleep / join)

  运行的线程执行 Thread.sleep 或 t.join 方法，或者发出了 I/O 请求时，JVM 会把该线程设置为阻塞状态，当 sleep 状态超时、join 等待线程终止或者超时、或者 I/O 处理完毕时，线程重新转入可运行状态



### 死亡（DEAD）

线程以下面三种方式结束，结束后进入死亡状态

- 正常结束

  run() 或 call() 方法执行完毕，线程正常结束

- 异常结束

  线程抛出一个未捕获的 Exception 或 Error

- 调用 stop

  调用该线程的 stop 方法来结束该线程