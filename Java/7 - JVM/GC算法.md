# JVM 垃圾回收



## 堆中内存分区

### 新生代

用来存放新生的对象，一般占堆空间的 1/3。由于频繁创建对象，新生代会频繁触发 Minor GC 进行垃圾回收。

#### Eden 区

Java 新对象的出生地，当 Eden 区内存不够时会触发 Minor GC，对新生代进行一次垃圾回收

#### From Survivor 区

上一次 GC 的幸存者，作为这一次 GC 的被扫描者

#### To Survivor 区

保留了一次 Minor GC 的幸存者



### 老年代

主要存放程序中生命周期长的内存对象。



## 确定回收对象

### 引用计数法

一个对象如果没有任何与之关联的引用，即引用计数为 0 时，则说明对象不太可能被用到，这个对象就是可回收对象。

但是会出现循环引用的问题，所以 Java 没有用这种方式，但 python 仍在使用



### 可达性分析

通过一系列 GC Root 对象作为根起点搜索，如果在 GC Root 和一个对象之间没有可达路径，则称该对象是不可达的。当不可达对象经过两次标记后仍是可回收的，则会被回收

GC Root 的对象包括了 VM 栈中的引用，方法区中的静态引用，和 JNI 的引用



### 四种引用

#### 强引用

Java 中平时用到的基本都是强引用。当一个对象被强引用变量引用时，处于可达状态，不会被垃圾回收。即使该对象一直不被用到，JVM 也不会回收，因此有可能造成内存泄漏

#### 软引用

需要使用 SoftReference 类来实现，对于只有软引用的对象，当系统内存足够时，不会被回收，当系统空间不足时他会被回收

#### 弱引用

需要使用 WeakReference 类来实现，与弱引用类似，但是生存期更短，对于只有弱引用的对象，不管内存空间是否足够，只要进行垃圾回收总会回收该对象的内存

#### 虚引用

虚引用需要 PhanotomReference 类来实现，不能单独使用，必须和引用队列联合使用，主要作用是跟踪对象被垃圾回收的状态



## 垃圾回收算法

### 标记清除

分为两个阶段，标记和清除，标记阶段标出所有需要回收的对象，清除阶段回收被标记对象所占用空间。

速度较快，但是存在内存碎片化的问题

### 复制

按内存容量将其划分为等大小的两块，每次只使用一块，当这一块内存存满后，将还存活的对象复制并整理到另一块内存，把已使用的内存清理空

内存效率高不产生碎片，但是可用内存被压缩到一半

### 标记整理

首先进行标记需要回收的对象，将存活对象进行整理移动到内存的一端，然后清除这之外的对象。



## 分代回收

根据对象存活的不同生命周期将内存划分为不同的域（老年代、新生代），根据不同的区域选择不同的算法。MinorGC 采用复制算法，FullGC 采用标记整理算法

- 对象首先分配在 Eden 区
- 当新生代空间不足时，触发 MinorGC，Eden区和From 区存活的对象使用 copy 复制到 to 中，存活的对象年龄加 1，并且交换 from 和 to

- MinorGC 时会引发 stop the world ，暂停其他用户线程，等垃圾回收结束，用户线程才恢复运行
- 当对象寿命超过阈值时，会晋升至老年代
- 当老年代空间不足，会先进行一次 MonorGC，若空间仍不组，则触发 FullGC

